/*
 * Books API
 *
 * This web service offers information on books
 *
 * API version: 0.1.9
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"encoding/json"
	"fmt"
	"net/http"
	"path"
)

var books = []Book{
	Book{BookId: "1", PublisherId: "1", Title: "Libro 1",
		Copyright: "2012", Edition: "5th", Pages: "976"},
	Book{BookId: "2", PublisherId: "1", Title: "Libro 2",
		Copyright: "2010", Edition: "9th", Pages: "1500"},
}

var authors = []Author{
	Author{AuthorId: "1", BookId: "1", Name: "OSCAR", Nationality: "Costa Rica",
		Birth: "1990", Genere: "First"},
	Author{AuthorId: "2", BookId: "2", Name: "MARIO", Nationality: "Costa Rica",
		Birth: "1991", Genere: "Second"},
}

var publishers = []Publisher{
	Publisher{PublisherId: "1", Name: "Yensie", Country: "Inglaterra", Founded: "Costa Rica",
		Genere: "First"},
	Publisher{PublisherId: "2", Name: "Tatiana", Country: "Italia", Founded: "Costa Rica",
		Genere: "Second"},
}

//BUSCA POR ID BOOOK
func findBook(x string) int {
	for i, book := range books {
		if x == book.BookId {
			return i
		}
	}
	return -1
}

//BUSCA POR ID AUTHOR
func findAuthor(x string) int {
	for i, author := range authors {
		if x == author.AuthorId {
			return i
		}
	}
	return -1
}

//BUSCA POR ID PUBLISHER
func findPublisher(x string) int {
	for i, publishers := range publishers {
		if x == publishers.PublisherId {
			return i
		}
	}
	return -1
}

//  /authors/1/books/
func AuthorsAuthorIdBooksGet(w http.ResponseWriter, r *http.Request) {
	fmt.Println("TEST")
	//	id1 := path.Abs(r.URL.Path)
	idTemp := path.Dir(r.URL.Path)
	idTemp2 := path.Dir(idTemp)

	id := path.Base(idTemp2)

	fmt.Println("URL -> ", id)

	//fmt.Println("Glob -> ", id6)
	i := findAuthor(id)
	if i == -1 {
		//return
		fmt.Println("Id Invalido")
	}

	json.NewEncoder(w).Encode(books)

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

//DELETE AUTHOR
func AuthorsAuthorIdDelete(w http.ResponseWriter, r *http.Request) {
	id := path.Base(r.URL.Path)
	i := findAuthor(id)
	if i == -1 {
		//return
		fmt.Println("Id Invalido")
	}
	authors = append(authors[:i], authors[i+1:]...)
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

// Obtiene el Author por ID
func AuthorsAuthorIdGet(w http.ResponseWriter, r *http.Request) {
	id := path.Base(r.URL.Path)
	i := findAuthor(id)
	if i == -1 {
		return
	}
	dataJson, _ := json.Marshal(authors[i])
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.Write(dataJson)
	w.WriteHeader(http.StatusOK)
}

//PUT AUTHOR
func AuthorsAuthorIdPut(w http.ResponseWriter, r *http.Request) {
	id := path.Base(r.URL.Path)

	for index, item := range authors {
		if item.AuthorId == id {
			authors = append(authors[:index], authors[index+1:]...)
			var author Author
			_ = json.NewDecoder(r.Body).Decode(&author)
			author.AuthorId = id
			authors = append(authors, author)
			json.NewEncoder(w).Encode(&author)
			return
		}
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

//POST AUTHOR
func AuthorsPost(w http.ResponseWriter, r *http.Request) {
	var author Author
	err := json.NewDecoder(r.Body).Decode(&author)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	authors = append(authors, author)
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

//  /books/1/authors/
func BooksBookIdAuthorsGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

//DELETE BOOK
func BooksBookIdDelete(w http.ResponseWriter, r *http.Request) {
	id := path.Base(r.URL.Path)
	i := findBook(id)
	if i == -1 {
		//return
		fmt.Println("Id Invalido")
	}
	books = append(books[:i], books[i+1:]...)
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

// Obtiene el Book por ID
func BooksBookIdGet(w http.ResponseWriter, r *http.Request) {
	id := path.Base(r.URL.Path)
	i := findBook(id)
	if i == -1 {
		return
	}
	dataJson, _ := json.Marshal(books[i])
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.Write(dataJson)
	w.WriteHeader(http.StatusOK)
}

//  /books/1/publishers/
func BooksBookIdPublishersGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

//PUT BOOK
func BooksBookIdPut(w http.ResponseWriter, r *http.Request) {
	id := path.Base(r.URL.Path)

	for index, item := range books {
		if item.BookId == id {
			books = append(books[:index], books[index+1:]...)
			var book Book
			_ = json.NewDecoder(r.Body).Decode(&book)
			book.BookId = id
			books = append(books, book)
			json.NewEncoder(w).Encode(&book)
			return
		}
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

//POST BOOK
func BooksPost(w http.ResponseWriter, r *http.Request) {
	var book Book
	err := json.NewDecoder(r.Body).Decode(&book)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	books = append(books, book)
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

//POST Publisher
func PublishersPost(w http.ResponseWriter, r *http.Request) {
	var publisher Publisher
	err := json.NewDecoder(r.Body).Decode(&publisher)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	publishers = append(publishers, publisher)
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

//  /publishers/1/books/
func PublishersPublisherIdBooksGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func PublishersPublisherIdDelete(w http.ResponseWriter, r *http.Request) {
	id := path.Base(r.URL.Path)
	i := findPublisher(id)
	if i == -1 {
		//return
		fmt.Println("Id Invalido")
	}
	publishers = append(publishers[:i], publishers[i+1:]...)
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

// Obtiene el Publisher por ID
func PublishersPublisherIdGet(w http.ResponseWriter, r *http.Request) {
	id := path.Base(r.URL.Path)
	i := findPublisher(id)
	if i == -1 {
		return
	}
	dataJson, _ := json.Marshal(publishers[i])
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.Write(dataJson)
	w.WriteHeader(http.StatusOK)
}

//PUT PUBLISHERS
func PublishersPublisherIdPut(w http.ResponseWriter, r *http.Request) {
	id := path.Base(r.URL.Path)

	for index, item := range publishers {
		if item.PublisherId == id {
			publishers = append(publishers[:index], publishers[index+1:]...)
			var publisher Publisher
			_ = json.NewDecoder(r.Body).Decode(&publisher)
			publisher.PublisherId = id
			publishers = append(publishers, publisher)
			json.NewEncoder(w).Encode(&publisher)
			return
		}
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)

	/*id := path.Base(r.URL.Path)
	i := findPublisher(id)
	if i == -1 {
		//return
		fmt.Println("Id Invalido")
	}
	publishers = append(publishers[:i], publishers[i+1:]...)

	len := r.ContentLength
	body := make([]byte, len)
	r.Body.Read(body)
	updatePublisher := Publisher{}
	json.Unmarshal(body, &updatePublisher)

	updatePublisher.PublisherId = id
	publishers = append(publishers, updatePublisher)
	json.NewEncoder(w).Encode(publishers)

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)*/
}
