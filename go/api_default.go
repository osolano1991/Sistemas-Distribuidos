/*
 * Books API
 *
 * This web service offers information on books
 *
 * API version: 0.1.9
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"encoding/json"
	"fmt"
	"net/http"
	"path"
	"strconv"
)

var books = []Book{
	Book{BookId: "1", PublisherId: "1", Title: "Libro 1",
		Copyright: "2012", Edition: "5th", Pages: "976"},
	Book{BookId: "2", PublisherId: "1", Title: "Libro 2",
		Copyright: "2010", Edition: "9th", Pages: "1500"},
	Book{BookId: "3", PublisherId: "1", Title: "Libro 3",
		Copyright: "2010", Edition: "9th", Pages: "1500"},
}

var authors = []Author{
	Author{AuthorId: "1", BookId: "3", Name: "OSCAR", Nationality: "Costa Rica",
		Birth: "1990", Genere: "First"},
	Author{AuthorId: "2", BookId: "2", Name: "MARIO", Nationality: "Costa Rica",
		Birth: "1991", Genere: "Second"},
	Author{AuthorId: "3", BookId: "2", Name: "LUIS", Nationality: "Costa Rica",
		Birth: "1991", Genere: "Third"},
	Author{AuthorId: "4", BookId: "2", Name: "JOUSER", Nationality: "FRANCES",
		Birth: "1980", Genere: "Fourth"},
}

var publishers = []Publisher{
	Publisher{PublisherId: "1", Name: "Yensie", Country: "Inglaterra", Founded: "Costa Rica",
		Genere: "First"},
	Publisher{PublisherId: "2", Name: "Tatiana", Country: "Italia", Founded: "Costa Rica",
		Genere: "Second"},
}

//BUSCA POR ID BOOOK
func findBook(x string) int {
	for _, book := range books {
		if x == book.BookId {
			s2, _ := strconv.Atoi(book.BookId)
			return s2
		}
	}
	return -1
}

//BUSCA POR ID BOOOK
func findBookPos(x string) int {
	for i, book := range books {
		if x == book.BookId {
			//s2, _ := strconv.Atoi(book.BookId)
			return i
		}
	}
	return -1
}

func findAuthorPos(x string) int {
	for i, author := range authors {
		if x == author.AuthorId {
			//s2, _ := strconv.Atoi(book.BookId)
			return i
		}
	}
	return -1
}

//BUSCA POR ID AUTHOR
func findAuthor(x string) int {
	for _, author := range authors {
		if x == author.AuthorId {
			//fmt.Println("Bookid", author.Name)
			s2, _ := strconv.Atoi(author.AuthorId)
			return s2
		}
	}
	return -1
}

//BUSCA POR ID Book
//   /books/1/authors/
func findAuthorIdbyBook(x string) int {
	for _, author := range authors {
		if x == author.BookId {
			fmt.Println("Author-BookId: ", author.BookId)
			fmt.Println("Author-AuthorId: ", author.AuthorId)
			s2, _ := strconv.Atoi(author.AuthorId)
			return s2
		}
	}
	return -1
}

//BUSCA POR ID AUTHOR
//   /authors/1/books/
func findBookIdbyAuthor(x string) int {
	for _, author := range authors {
		if x == author.AuthorId {
			//	fmt.Println("BookId-Author: ", author.AuthorId)
			s2, _ := strconv.Atoi(author.BookId)
			return s2
		}
	}
	return -1
}

//BUSCA POR ID PUBLISHER
func findPublisher(x string) int {
	for _, publishers := range publishers {
		if x == publishers.PublisherId {
			s2, _ := strconv.Atoi(publishers.PublisherId)
			return s2
		}
	}
	return -1
}

//BUSCA POR ID PUBLISHER
func findPublisherPos(x string) int {
	for i, publishers := range publishers {
		if x == publishers.PublisherId {
			//s2, _ := strconv.Atoi(publishers.PublisherId)
			return i
		}
	}
	return -1
}

//  /authors/1/books/
func AuthorsAuthorIdBooksGet(w http.ResponseWriter, r *http.Request) {
	//Obtener el id del Author del path
	idTemp := path.Dir(r.URL.Path)
	idTemp2 := path.Dir(idTemp)

	id := path.Base(idTemp2)
	//Se busca el id del path en los autores
	i := findAuthor(id)
	if i != -1 {
		//se parsea de int to String
		s := strconv.Itoa(i)
		//Si existe el author se obtiene el id del libro del author
		idBook := findBookIdbyAuthor(s)
		if idBook != -1 {
			//se parsea de int to String
			p := strconv.Itoa(idBook)
			//Se busca el Id del libro obtenido del author en Book
			bookId := findBook(p)
			if bookId != -1 {
				p2 := strconv.Itoa(bookId)
				bookId2 := findBookPos(p2)
				dataJson, _ := json.Marshal(books[bookId2])
				w.Header().Set("Content-Type", "application/json; charset=UTF-8")
				w.Write(dataJson)
				w.WriteHeader(http.StatusOK)
			} else {
				fmt.Println("findBook invalido")
			}
		} else {
			fmt.Println("idBook invalido")
		}
	} else {
		fmt.Println("idAuthor invalido")
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

//DELETE AUTHOR
func AuthorsAuthorIdDelete(w http.ResponseWriter, r *http.Request) {
	id := path.Base(r.URL.Path)
	i := findAuthorPos(id)
	if i == -1 {
		//return
		fmt.Println("Id Invalido")
	}
	authors = append(authors[:i], authors[i+1:]...)
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

// Obtiene el Author por ID
func AuthorsAuthorIdGet(w http.ResponseWriter, r *http.Request) {
	id := path.Base(r.URL.Path)
	i := findAuthorPos(id)
	if i == -1 {
		return
	}
	dataJson, _ := json.Marshal(authors[i])
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.Write(dataJson)
	w.WriteHeader(http.StatusOK)
}

//PUT AUTHOR
func AuthorsAuthorIdPut(w http.ResponseWriter, r *http.Request) {
	id := path.Base(r.URL.Path)

	for index, item := range authors {
		if item.AuthorId == id {
			authors = append(authors[:index], authors[index+1:]...)
			var author Author
			_ = json.NewDecoder(r.Body).Decode(&author)
			author.AuthorId = id
			authors = append(authors, author)
			json.NewEncoder(w).Encode(&author)
			return
		}
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

//POST AUTHOR
func AuthorsPost(w http.ResponseWriter, r *http.Request) {
	var author Author
	err := json.NewDecoder(r.Body).Decode(&author)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	authors = append(authors, author)
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

//  /books/1/authors/
func BooksBookIdAuthorsGet(w http.ResponseWriter, r *http.Request) {

	//Obtener el id del Libro del path
	idTemp := path.Dir(r.URL.Path)
	idTemp2 := path.Dir(idTemp)

	id := path.Base(idTemp2)
	//Se busca el id del path en los libros
	i := findBook(id)
	if i != -1 {
		//se parsea de int to String
		s := strconv.Itoa(i)
		//Si existe el libro se obtiene el id del author del libro
		//idBook := findBookIdbyAuthor(s)
		idBook := findAuthorIdbyBook(s)
		fmt.Println("Id Author", idBook)
		if idBook != -1 {
			//se parsea de int to String
			p := strconv.Itoa(idBook)
			//Se busca el Id del authot obtenido del libro en Author
			bookId := findAuthor(p)
			if bookId != -1 {
				p2 := strconv.Itoa(bookId)
				bookId2 := findAuthorPos(p2)
				dataJson, _ := json.Marshal(authors[bookId2])
				w.Header().Set("Content-Type", "application/json; charset=UTF-8")
				w.Write(dataJson)
				w.WriteHeader(http.StatusOK)
			} else {
				fmt.Println("findBook invalido")
			}
		} else {
			fmt.Println("idBook invalido")
		}
	} else {
		fmt.Println("idAuthor invalido")
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

//DELETE BOOK
func BooksBookIdDelete(w http.ResponseWriter, r *http.Request) {
	id := path.Base(r.URL.Path)
	i := findBookPos(id)
	if i == -1 {
		//return
		fmt.Println("Id Invalido")
	}
	books = append(books[:i], books[i+1:]...)
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

// Obtiene el Book por ID
func BooksBookIdGet(w http.ResponseWriter, r *http.Request) {
	id := path.Base(r.URL.Path)
	i := findBookPos(id)
	if i == -1 {
		return
	}
	dataJson, _ := json.Marshal(books[i])
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.Write(dataJson)
	w.WriteHeader(http.StatusOK)
}

//  /books/1/publishers/
func BooksBookIdPublishersGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

//PUT BOOK
func BooksBookIdPut(w http.ResponseWriter, r *http.Request) {
	id := path.Base(r.URL.Path)

	for index, item := range books {
		if item.BookId == id {
			books = append(books[:index], books[index+1:]...)
			var book Book
			_ = json.NewDecoder(r.Body).Decode(&book)
			book.BookId = id
			books = append(books, book)
			json.NewEncoder(w).Encode(&book)
			return
		}
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

//POST BOOK
func BooksPost(w http.ResponseWriter, r *http.Request) {
	var book Book
	err := json.NewDecoder(r.Body).Decode(&book)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	books = append(books, book)
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

//POST Publisher
func PublishersPost(w http.ResponseWriter, r *http.Request) {
	var publisher Publisher
	err := json.NewDecoder(r.Body).Decode(&publisher)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	publishers = append(publishers, publisher)
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

//  /publishers/1/books/
func PublishersPublisherIdBooksGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func PublishersPublisherIdDelete(w http.ResponseWriter, r *http.Request) {
	id := path.Base(r.URL.Path)
	i := findPublisherPos(id)
	if i == -1 {
		//return
		fmt.Println("Id Invalido")
	}
	publishers = append(publishers[:i], publishers[i+1:]...)
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

// Obtiene el Publisher por ID
func PublishersPublisherIdGet(w http.ResponseWriter, r *http.Request) {
	id := path.Base(r.URL.Path)
	i := findPublisherPos(id)
	if i == -1 {
		return
	}
	dataJson, _ := json.Marshal(publishers[i])
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.Write(dataJson)
	w.WriteHeader(http.StatusOK)
}

//PUT PUBLISHERS
func PublishersPublisherIdPut(w http.ResponseWriter, r *http.Request) {
	id := path.Base(r.URL.Path)

	for index, item := range publishers {
		if item.PublisherId == id {
			publishers = append(publishers[:index], publishers[index+1:]...)
			var publisher Publisher
			_ = json.NewDecoder(r.Body).Decode(&publisher)
			publisher.PublisherId = id
			publishers = append(publishers, publisher)
			json.NewEncoder(w).Encode(&publisher)
			return
		}
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)

	/*id := path.Base(r.URL.Path)
	i := findPublisher(id)
	if i == -1 {
		//return
		fmt.Println("Id Invalido")
	}
	publishers = append(publishers[:i], publishers[i+1:]...)

	len := r.ContentLength
	body := make([]byte, len)
	r.Body.Read(body)
	updatePublisher := Publisher{}
	json.Unmarshal(body, &updatePublisher)

	updatePublisher.PublisherId = id
	publishers = append(publishers, updatePublisher)
	json.NewEncoder(w).Encode(publishers)

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)*/
}
